---
title: "Practical Machine Learning - Peer Assignment"
author: "Fabrice Tereszkiewicz"
date: "14 Nov 2015"
output: html_document
---

```{r global_options, include=FALSE}
knitr::opts_chunk$set(warning=FALSE, message=FALSE)
library('ggplot2')
library('caret')
library('dplyr')
library('parallel')
library('doMC')
registerDoMC(cores=detectCores())
```

## Introduction

Using devices such as Jawbone Up, Nike FuelBand, and Fitbit it is now possible to collect a large amount of data about personal activity relatively inexpensively. These type of devices are part of the quantified self movement â€“ a group of enthusiasts who take measurements about themselves regularly to improve their health, to find patterns in their behavior, or because they are tech geeks. One thing that people regularly do is quantify how much of a particular activity they do, but they rarely quantify how well they do it. In this project, our goal is to use data from accelerometers on the belt, forearm, arm, and dumbell of 6 participants. They were asked to perform barbell lifts correctly and incorrectly in 5 different ways (exercise class). We will build a model to predict the exercise class based on the data from the accelerometers.

## Data

```{r load_data, cache=TRUE}
if (!file.exists("./data/pml-training.csv")) {
    download.file("https://d396qusza40orc.cloudfront.net/predmachlearn/pml-training.csv", 
        "./data/pml-training.csv", method='curl')
}
if (!file.exists("./data/pml-testing.csv")) {
    download.file("https://d396qusza40orc.cloudfront.net/predmachlearn/pml-testing.csv", 
        "./data/pml-testing.csv", method='curl')
}

df_train_base <- read.csv('./data/pml-training.csv', sep=',', stringsAsFactors = FALSE, strip.white = TRUE)
df_test_base <- read.csv('./data/pml-testing.csv', sep=',', strip.white = TRUE, stringsAsFactors = FALSE)
```

We set an initial seed to ensure this analysis can be reproduced:

```{r}
set.seed(123)
```

## Exploratory Analysis

The training set contains `r dim(df_train_base)[1]` observations and `r dim(df_train_base)[2]` features. We can see that some features are only present for some observations. These observations correspond to observations windows where the data from the sensors is being derived (average, variance, etc..). The windows last 0.5 seconds to 2.5 seconds and correspond to one exercise class. This approach taken by the research team can not be used for our problem as the observations we have to predict are instantaneous measurements.

We can therefore clean up the dataset by removing all the derived data generated by the research team for their window based approach. Also the time related data are not relevant for our exercise as we're looking to classify instatanous measurements. Finally, the name of the participant and the X feature are also irrelevant.

```{r}
df_train <- df_train_base %>%
    select(-starts_with("avg_"),
           -starts_with("var_"),
           -starts_with("stddev_"),
           -starts_with("max_"),
           -starts_with("min_"),
           -starts_with("amplitude_"),
           -starts_with("kurtosis_"),
           -starts_with("skewness_"),
           -new_window,
           -num_window,
           -user_name,
           -raw_timestamp_part_1,
           -raw_timestamp_part_2,
           -cvtd_timestamp,
           -X)
dim(df_train)
```

We are now left with `r dim(df_train)[2]` features corresponding to instantaneous measurements of the sensors installed on the participants.

The output is the class and must be converted to a factor:

```{r}
df_train$classe <- as.factor(df_train$classe)
```

## Training

We will split the training set to keep a test set on the side in order to estimate the performances of our models. Here the split is to keep 70% of the data for training, and the remaining 30% for testing. We will use the testing set to estimate the out-of-sample accuracy of our model.

```{r}
inTrain <- createDataPartition(y=df_train$classe, p=0.7, list=FALSE)
training <- df_train[inTrain, ]
testing <- df_train[-inTrain,]
```

We can now train a random forest model, using a 3-fold cross validation to determine the best parameters.

```{r, cache=TRUE}
myTrainControl <- trainControl(method="cv", number=3)
modFit <- train(classe ~ ., method="rf", data=training, prox=TRUE, trControl = myTrainControl)
```

The final model:

```{r}
modFit$finalModel
```

We can see that some observations has been missclassified, the error rate of the model using cross validation is 0.72%, meaning an accuracy of more than 99%. This is really good and we can think that our model may be overfitting the training data.

To estimate more realistically the out-of-sample error of our model, we can now use the testing set that we defined earlier. Let's predict the classes of the testing observations and compare to their real values.

```{r}
pred <- predict(modFit, testing)
confusionMatrix(table(pred, testing$classe))
```

We can see some missclassification as well on the testing set. The estimated accuracy is 99.32% which is very good. We can confidently use this model for the prediction of the remaining data.

## Credits

The data used in this analysis is provided by http://groupware.les.inf.puc-rio.br/har .